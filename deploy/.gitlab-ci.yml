# LTC GitLab CI/CD Source Project Pipeline
#
## Requirements
#   - this file
#   - a working `Dockerfile`
#   - a deployment package (see https://infrastructure-documentation.ltc.bcit.ca/)
#
## General Pipeline Steps
#   1. Gather info
#   2. Build image
#   3. Deploy to a cluster
#     - development branches        => https://review_{branchName}_{projectName}.ltc.bcit.ca/   => review
#     - main branch                 => https://latest_{projectName}.ltc.bcit.ca/                => latest
#     - public endpoint             => https://{projectName}.ltc.bcit.ca/                       => stable

stages:
  - get info
  - test
  - publish
  - cleanup

## Project initialization
#   - a project access token is required; if it doesn't exist it is created on the first run
# project init:
#   stage: get info
#   extends:
#     - ".project_init"

## Are there existing git tags? Is a new tag required?
get info:
  stage: get info
  extends:
    - ".get_info"

## Build image and push to project registry
build image:
  stage: publish
  extends:
    - ".build_image"
    - ".build_image_rules"

## Deploy to a development branch for review
#   - uses a deployment package with a `review` overlay
#   - `generic-dev` deployment package is used if one hasn't been initialized
deploy review:
  image: registry.ltc.bcit.ca/ltc-infrastructure/images/kpt-git-kubectl-docker-kustomize
  secrets:
    VAULT_CERT_USER:
      vault: pki-ltc-cert-issuer/username@ltc-infrastructure
      file: false

    VAULT_CERT_USER_PASSWORD:
      vault: pki-ltc-cert-issuer/password@ltc-infrastructure
      file: false

    TLS_CRT:
      vault: ssl-certificates/star-ltc-bcit-ca-bundle.crt.base64@ltc-infrastructure
      file: false

    TLS_KEY:
      vault: ssl-certificates/star-ltc-bcit-ca.key.base64@ltc-infrastructure
      file: false

  stage: publish
  extends:
    - ".deploy_review_rules"

  variables:
    TARGET_ENV: review
    DEPLOY_PKG_URL: "https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}/deployments/${CI_PROJECT_NAME}.git"
    CONTAINER_NAME: ${CI_PROJECT_NAME}
    IMAGE_NAME: ${CI_REGISTRY_IMAGE}
    DEPLOY_NAMESPACE: ${CI_COMMIT_REF_SLUG} # eg. 425-experimental-function-as-a-service-endpoint
    VAULT_AUTH_ROLE: "${CI_PROJECT_NAME}-dependabot"
    VAULT_ADDR: "${VAULT_SERVER_URL}"
    DOCKER_HOST: "tcp://${HOST_DOCKER_DAEMON}:2376"
    DOCKER_TLS_VERIFY: "1"
    INGRESS_HOST: "review_${CI_COMMIT_REF_SLUG}_${CI_PROJECT_NAME}" # eg. review_425-experimental-function-as-a-service-endpoint_qcon-api

  before_script:

    # Set kubernetes context based on TARGET_ENV
    - !reference [.set-kubernetes-context, script]

    # Apply config overrides for generic deployment and common namespaces
    - !reference [.generic-deployment, script]
    - !reference [.common-namespace, script]

    # Retrieve vault token and generate certs for remote Docker calls
    - !reference [.get-vault-token, script]
    - !reference [.get-vault-certs, script]

  script:

    # Check for namespace; if it doesn't exist, create it
    - !reference [.create-namespace, script]

    # Hydrate the package
    - |-
      #
      echo "Hydrating deployment package with kpt..."

      if [[ -n "${SKIP_BUILD}" ]]; then 
        echo "  Skip build set. Setting IMAGE_TAG to \"latest\"."; IMAGE_TAG=latest
      fi

      IMAGE_REF="[{name: \"${CONTAINER_NAME}\", newName: \"${IMAGE_NAME}\", newTag: \"${IMAGE_TAG}\"}]"

      if [[ ${PIPELINE_DEBUG} == "true" ]]; then
        echo -e "
          \n\e[31m##### pre-hydrate package debug #####\e[0m
          TARGET_ENV: ${TARGET_ENV}
          DEPLOY_NAMESPACE: ${DEPLOY_NAMESPACE}
          COMMON_NAMESPACE: ${COMMON_NAMESPACE}
          INGRESS_HOST: ${INGRESS_HOST}
          GIT_TAG: ${GIT_TAG}
          CONTAINER_NAME: ${CONTAINER_NAME}
          IMAGE_NAME: ${IMAGE_NAME}
          IMAGE_TAG: ${IMAGE_TAG}
          IMAGE_REF: ${IMAGE_REF}
        "
        # print out file contents in subfolders
        shopt -s globstar
        for FILE in bases/**/*.yaml; do echo -e "\n\n\e[33m##### ${FILE}: #####\e[0m\n"; cat ${FILE}; echo; done
        for FILE in overlays/${TARGET_ENV}/*.yaml; do echo -e "\n\n\e[33m##### ${FILE}: #####\e[0m\n"; cat ${FILE}; echo; done
      fi


      if kpt fn eval deploy/overlays/${TARGET_ENV} \
        --truncate-output=false \
        --image gcr.io/kpt-fn/apply-setters:v0.2.0 -- \
        TARGET_ENV=${TARGET_ENV} \
        DEPLOY_NAMESPACE=${DEPLOY_NAMESPACE} \
        INGRESS_HOST=${INGRESS_HOST} \
        GIT_TAG=${GIT_TAG} \
        IMAGE_REF="${IMAGE_REF}" \
        && \
        kpt fn render deploy/overlays/${TARGET_ENV}; then

        echo "
          ...hydration successful.
        "
      else
        echo -e "\n\e[31m-- hydration failed --\e[0m"
      fi

    # Inject TLS certificates
    - |-
      #
      echo "Checking if we should inject TLS certificates..."
      
      if [[ "${TARGET_ENV}" == "review" ]] \
        || [[ "${TARGET_ENV}" == "latest" ]] \
        || [[ "${TARGET_ENV}" == "web" ]] \
        || [[ "${TARGET_ENV}" == "stable" ]]; then

        echo "
          TARGET ENV=${TARGET_ENV}.
          Injecting \"star.ltc.bcit.ca\" certificate into deployment package...
        "

        echo "${TLS_CRT}" | base64 --decode > deploy/overlays/${TARGET_ENV}/secrets/tls.crt
        echo "${TLS_KEY}" | base64 --decode > deploy/overlays/${TARGET_ENV}/secrets/tls.key
        chmod 0600 deploy/overlays/${TARGET_ENV}/secrets/tls.key

        echo "  ...certificates injected successfully."

      else
        echo "  TARGET_ENV not set. Certificate injection skipped."
      fi

    # Determine if the package already exists on the cluster
    - |-
      #
      echo "Checking deployment package for inventory..."
      cd deploy

      # check deployment package for `resourcegroup` CRD
      if [[ -f "overlays/${TARGET_ENV}/resourcegroup.yaml" ]]; then
        echo "  A ResourceGroup already exists in the de
        ployment package."
        DEPLOY_PKG_EXISTS="true"
        
        PKG_RESOURCE_GROUP_NAME=$(yq e '.metadata.name' overlays/${TARGET_ENV}/resourcegroup.yaml)
        PKG_INVENTORY_ID=$(yq e '.metadata.labels."cli-utils.sigs.k8s.io/inventory-id"' overlays/${TARGET_ENV}/resourcegroup.yaml)

      else
        echo "  No existing deployment package inventory found."
        DEPLOY_PKG_EXISTS="false"
      fi

      echo "Checking cluster for inventory..."
 
      # retrieve resourcegroups in the cluster namespace
      kubectl get resourcegroup -o json -n ${DEPLOY_NAMESPACE} > cluster-resource-groups.json

      # determine how many resourcegroups in the namespace
      NUMBER_RESOURCEGROUPS=$(jq '[.items[].metadata.name] | length' cluster-resource-groups.json)

      if [[ "${NUMBER_RESOURCEGROUPS}" -eq 1 ]]; then
        echo "  ...cluster package found. Retrieving name and inventory-id..."

        # parse out name, inventory-id
        CLUSTER_PKG_EXISTS="true"
        CLUSTER_RESOURCE_GROUP_NAME=$(jq -r '.items[].metadata.name' cluster-resource-groups.json )
        CLUSTER_INVENTORY_ID=$(jq -r '.items[].metadata.labels."cli-utils.sigs.k8s.io/inventory-id"' cluster-resource-groups.json)

        echo "...done."

      elif [[ "${NUMBER_RESOURCEGROUPS}" -gt 1 ]]; then
        echo "  Multiple inventories found. Attempting to find matching resourcegroup..."

        # determine if a resourcegroup's name contains the CONTAINER_NAME
        CLUSTER_PKG_EXISTS=$(jq -r --arg name "${CONTAINER_NAME}" '[.items[].metadata|select(.name|contains($name))|.name|test($name)]|any' cluster-resource-groups.json)
        CLUSTER_RESOURCE_GROUP_NAME=$(jq -r --arg name "${CONTAINER_NAME}" '.items[].metadata|select(.name|contains($name))|.name' cluster-resource-groups.json)
        CLUSTER_INVENTORY_ID=$(jq -r --arg name "${CONTAINER_NAME}" '.items[].metadata|select(.name|contains($name))|.labels."cli-utils.sigs.k8s.io/inventory-id"' cluster-resource-groups.json)

        echo "  Matched 'inventory-id': ${CLUSTER_INVENTORY_ID}"

      else
        echo "  No existing cluster package inventory found."
        CLUSTER_PKG_EXISTS="false"
      fi


      if [[ ${PIPELINE_DEBUG} == "true" ]]; then
        echo -e "
          \n\e[31m##### check inventory pre-init debug #####\e[0m
          TARGET_ENV: ${TARGET_ENV}
          DEPLOY_PKG_EXISTS: ${DEPLOY_PKG_EXISTS}
          PKG_RESOURCE_GROUP_NAME: ${PKG_RESOURCE_GROUP_NAME}
          PKG_INVENTORY_ID: ${PKG_INVENTORY_ID}
          DEPLOY_NAMESPACE: ${DEPLOY_NAMESPACE}
          COMMON_NAMESPACE: ${COMMON_NAMESPACE}
          COMMON_NAMESPACE_OVERRIDE: ${COMMON_NAMESPACE_OVERRIDE}
          CONTAINER_NAME: ${CONTAINER_NAME}
          CLUSTER_PKG_EXISTS: ${CLUSTER_PKG_EXISTS}
          UNDEPLOY: ${UNDEPLOY}
          CLUSTER_RESOURCE_GROUP_NAME: ${CLUSTER_RESOURCE_GROUP_NAME}
          CLUSTER_INVENTORY_ID: ${CLUSTER_INVENTORY_ID}
          \n\e[33m##### cluster-resource-groups.json: #####\e[0m
          \n$(cat cluster-resource-groups.json)
        "
      fi


      # for development, ResourceGroups only ever exist in the cluster. Review branch updates are facilitated by rebuilding a copy from the cluster
      if ([[ "${TARGET_ENV}" == "review" ]] && [[ "${CLUSTER_PKG_EXISTS}" == "true" ]]) || [[ "${UNDEPLOY}" == "true" ]]; then
        echo -e "  Existing \"review\" ResourceGroup found on the cluster. \n  Using this inventory to rebuild the local version."

        kpt live init --namespace=${DEPLOY_NAMESPACE} --name=resourcegroup --inventory-id=${CLUSTER_INVENTORY_ID} overlays/${TARGET_ENV}

      elif [[ "${TARGET_ENV}" == "review" ]] && [[ "${CLUSTER_PKG_EXISTS}" == "false" ]]; then
        echo "  No existing \"review\" inventory found... initializing."

        kpt live init --namespace=${DEPLOY_NAMESPACE} --name=resourcegroup overlays/${TARGET_ENV}

      fi

      # for latest/stable/web
      if [[ "${TARGET_ENV}" != "review" ]] && [[ ${DEPLOY_PKG_EXISTS} == "false" ]] && [[ "${CLUSTER_PKG_EXISTS}" == "true" ]]; then
        echo "  Existing ResourceGroup found on the cluster but no deployment package resourcegroup found... Rebuilding."

        kpt live init --namespace=${DEPLOY_NAMESPACE} --name=resourcegroup --inventory-id=${CLUSTER_INVENTORY_ID} overlays/${TARGET_ENV}

      # initialize a new resourcegroup
      elif [[ "${TARGET_ENV}" != "review" ]] && [[ ${DEPLOY_PKG_EXISTS} == "false" ]] && [[ "${CLUSTER_PKG_EXISTS}" == "false" ]]; then
        echo "  No existing ResourceGroup found on either the cluster or in the deployment package... Initializing."

        kpt live init --namespace=${DEPLOY_NAMESPACE} --name=resourcegroup overlays/${TARGET_ENV}

      # if both exist, force rebuild based on cluster resourcegroup
      elif [[ "${TARGET_ENV}" != "review" ]] && [[ ${DEPLOY_PKG_EXISTS} == "true" ]] && [[ "${CLUSTER_PKG_EXISTS}" == "true" ]]; then
        echo -e "
          ResourceGroups found in both the deployment package and the cluster...\n\n

          PKG_INVENTORY_ID: ${PKG_INVENTORY_ID}
          CLUSTER_INVENTORY_ID: ${CLUSTER_INVENTORY_ID}

        "
        if [[ "${PKG_INVENTORY_ID}" == "${CLUSTER_INVENTORY_ID}" ]]; then
          echo "  Looks good. Using deployment package resourcegroup as is."
        else
          echo "  Not good. Using cluster resourcegroup to force rebuild package inventory."

          kpt live init --force --namespace=${DEPLOY_NAMESPACE} --name=resourcegroup --inventory-id=${CLUSTER_INVENTORY_ID} overlays/${TARGET_ENV}
        fi

      # effectively skipping
      elif [[ "${TARGET_ENV}" != "review" ]] && [[ "${DEPLOY_PKG_EXISTS}" == "true" ]] && [[ "${CLUSTER_PKG_EXISTS}" == "false" ]]; then
        echo "  ResourceGroup found in the deployment package but not on the cluster... Deploying resources from the deployment package."
      fi

      # remove temp file
      rm -Rf cluster-resource-groups.json


      if [[ ${PIPELINE_DEBUG} == "true" ]]; then
        echo -e "
          \n\e[31m##### check inventory post-init debug #####\e[0m
          \n\e[33m##### overlays/${TARGET_ENV}/kustomization.yaml: #####\e[0m
          \n$(cat overlays/${TARGET_ENV}/kustomization.yaml)
          \n\e[33m##### overlays/${TARGET_ENV}/resourcegroup.yaml: #####\e[0m
          \n$(cat overlays/${TARGET_ENV}/resourcegroup.yaml)
          \n\e[33m##### directory listing: #####\e[0m\n$(pwd):
          \n$(tree)
        "
      fi

    # Apply kustomized resources to cluster
    - |-
      #
      echo "Applying resources to ${ENV_REVIEW} - ${TARGET_ENV}..."


      if [[ ${PIPELINE_DEBUG} == "true" ]]; then
        echo -e "
          \n\e[31m##### pre-apply debug #####\e[0m\n
          TARGET_ENV: ${TARGET_ENV}
          DEPLOY_NAMESPACE: ${DEPLOY_NAMESPACE}
          \n\e[33m##### directory listing: #####\e[0m\n$(pwd):
          \n$(tree)
          \n\e[33m##### pre-apply kustomized resources #####\e[0m
          \n$(kubectl kustomize overlays/${TARGET_ENV} | sed -e '/^  tls.key/,/kind/d' -e 's/tls.crt:.*/tls.key truncated...\nkind: Secret/')
        "
      fi


      # Allow namespace resource overlap if COMMON_NAMESPACE is set
      if [[ -n "${COMMON_NAMESPACE}" ]]; then
        echo "COMMON_NAMESPACE set. Adjusting inventory-policy to adopt..."

        kubectl kustomize overlays/${TARGET_ENV} | kpt live apply - --reconcile-timeout=12m --inventory-policy=adopt

      else
        kubectl kustomize overlays/${TARGET_ENV} | kpt live apply - --reconcile-timeout=12m
      fi

  environment:
    name: review/${DEPLOY_NAMESPACE}
    url: https://${INGRESS_HOST}.ltc.bcit.ca/
#    on_stop: stop review
#    auto_stop_in: 1 week

  tags:
    - review


## Deploy latest/stable packages
#   - must have a deployment package with `latest` and `stable` overlays
#   - triggers pipelines in GitLab "Deployments/{projectName}" project
# deploy to latest:
#   stage: publish
#   variables:
#     TARGET_ENV: latest
#   extends:
#     - ".deploy"
#     - ".deploy_latest_rules"
#   environment:
#     name: latest
#     url: https://latest_${CI_PROJECT_NAME}.ltc.bcit.ca

# deploy to stable:
#   stage: publish
#   variables:
#     TARGET_ENV: stable
#   extends:
#     - ".deploy"
#     - ".deploy_stable_rules"
#   environment:
#     name: stable
#     url: https://${CI_PROJECT_NAME}.ltc.bcit.ca

# ## Removes dev branch review (and all assets in the review branch namespace)
# stop review:
#   stage: cleanup
#   extends:
#     - ".undeploy_review"
#     - ".undeploy_review_rules"

#
## ---------- Pipeline configuration ----------
#
variables:
  #
  # other global variables are set in GitLab Admin
  #
  # GENERIC_DEPLOYMENT: "true"
  #
  #   - if GENERIC_DEPLOYMENT is set to anything but "true", the pipeline expects a deployment package
  #     to exist in the GitLab "Deployments" group. Create a deployment package following the
  #     guide at https://infrastructure-documentation.ltc.bcit.ca/.
  #
  #
  # Set DEPLOY_PKG_INIT=true to create an initial project deployment package. Then unset GENERIC_DEPLOYMENT and
  # add the deployment package project ID below
  #
  # DEPLOY_PKG_INIT: "true"
  # DEPLOY_PKG_PROJECT_ID: "403"
  #
  # Set COMMON_NAMESPACE to combine apps into one namespace.
  # COMMON_NAMESPACE: ""
  #
  # Deploy "development" overlay to a common namespace (the default is to deploy development branches to branch name namespaces)
  # COMMON_NAMESPACE_OVERRIDE: "true"
  #
  # Set SKIP_BUILD to skip the build stage and deploy the latest image
  # SKIP_BUILD: "true"
  #
  PIPELINE_DEBUG: "true"
#
#
#
## ---------- It's generally bad to change anything below here ----------
#
#
#
## Include common scripts
include:
  - project: deployments/ci-config
    file:
      # - project-init.yml
      - get-info.yml
      - build.yml
      # - deploy-new.yml
      - rules.yml
      - ".common-utilities.yml"
      - ".vault.yml"
      - ".source-utilities.yml"
  # - template: Jobs/Secret-Detection.gitlab-ci.yml
  # - template: Jobs/SAST.gitlab-ci.yml

## Specify which runner should pick up pipeline jobs
default:
  tags:
    - utility

## Cache jobs based on branch
cache:
  key: $CI_COMMIT_REF_SLUG

## Configure security scanning
# sast:
#   stage: test
#   extends:
#     - ".deploy_stable_rules"

## Configure merge request pipelines
workflow:
  rules:
    - if: $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS && $CI_PIPELINE_SOURCE == "push"
      when: never
    - if: "$CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS"
      when: never
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" || $CI_COMMIT_BRANCH || $CI_COMMIT_TAG

