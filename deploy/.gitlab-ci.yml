# LTC GitLab CI/CD Source Project Pipeline
#
## Requirements
#   - this file
#   - a working `Dockerfile`
#   - a `deploy/` folder with Kubernetes resources
#
## General Pipeline Steps
#   1. Gather info
#   2. Build image
#   3. FluxCD deploys resources to a cluster
#     - dev branches          => https://review--{branchName}--{projectName}.ltc.bcit.ca/ => review cluster
#     - main branch           => https://latest--{projectName}.ltc.bcit.ca/               => latest cluster
#     - tagged commit on main => https://{projectName}.ltc.bcit.ca/                       => stable cluster

stages:
  - get info
  - test
  - publish
  - review
  - cleanup


## Project initialization
#   - a project access token is required; if it doesn't exist it is created on the first run
# project init:
#   stage: get info
#   extends:
#     - ".project_init"


get_info:
  image: registry.ltc.bcit.ca/ltc-infrastructure/images/semantic-release
  secrets:
    GITLAB_TOKEN:
      vault: ${CI_PROJECT_NAME}-dependabot/token@tokens
      file: false

  variables:
    VAULT_AUTH_ROLE: "${CI_PROJECT_NAME}-dependabot"
    GIT_AUTHOR_NAME: ${GITLAB_USER_LOGIN}
    GIT_AUTHOR_EMAIL: ${GITLAB_USER_EMAIL}
    GIT_COMMITTER_NAME: ${GITLAB_USER_LOGIN}
    GIT_COMMITTER_EMAIL: ${GITLAB_USER_EMAIL}
    # required for semantic-release
    GITLAB_URL: ${CI_SERVER_URL}
    GITLAB_PREFIX: "/api/v4"
    GIT_FETCH_EXTRA_FLAGS: "--tags"

  script:

    # Run semantic-release if the branch is main ("latest" or "stable")
    - |
      #
      echo "Checking if we should run semantic-release..."


      if [[ ${PIPELINE_DEBUG} == "true" ]]; then
        echo -e "
          \n\e[31m##### get_info debug #####\e[0m
          CI_COMMIT_REF_SLUG: ${CI_COMMIT_REF_SLUG}
          CI_PIPELINE_SOURCE: ${CI_PIPELINE_SOURCE}
        "
      fi


      if [[ "${CI_COMMIT_REF_SLUG}" == "main" ]] \
        && ([[ "${CI_PIPELINE_SOURCE}" == "push" ]] \
        || [[ "${CI_COMMIT_TAG}" ]]) ; then

        echo "
          ...main branch detected. Running semantic-release!
        "


        if [[ ${PIPELINE_DEBUG} == "true" ]]; then
          echo -e "
            \n\e[31m##### semantic-release debug #####\e[0m
            GIT_AUTHOR_NAME: $GIT_AUTHOR_NAME
            GIT_AUTHOR_EMAIL: $GIT_AUTHOR_EMAIL
            GIT_COMMITTER_NAME: $GIT_COMMITTER_NAME
            GIT_COMMITTER_EMAIL: $GIT_COMMITTER_EMAIL
          "

          NEXT_VERSION=$(semantic-release \
            --debug \
            --branches main \
            --dry-run \
            --repository-url ${CI_PROJECT_URL} \
            --plugins '@semantic-release/commit-analyzer, @semantic-release/release-notes-generator, @semantic-release/gitlab' | grep -oP 'The release version is \K[0-9]+\.[0-9]+\.[0-9]+') \
            && echo $NEXT_VERSION

          if [ -n "${NEXT_VERSION}" ]; then
            echo "Determined next version $NEXT_VERSION"
          else
            echo "No new version to be released."
          fi

        else
          semantic-release \
            --branches main \
            --repository-url ${CI_PROJECT_URL} \
            --plugins '@semantic-release/commit-analyzer, @semantic-release/release-notes-generator, @semantic-release/gitlab'
        fi


      else
        echo "
          ...branch other than main detected. Not running semantic-release.
        "
      fi
      

# # Retrieve tags and target environment info for downstream pipeline jobs
# get tags:
#   extends:
#     - ".get_tags"

# # Determine deployment namespace and ingress/app url for downstream pipeline jobs
# get namespace/url:
#   extends:
#     - ".get_ns-url"

# # Determine if a new git tag and GitLab release should be created
# run semantic release:
#   extends:
#     - ".semantic_release"

# ## Verify and create required Kubernetes resources
# verify namespace:
#   extends:
#     - ".verify_namespace"
#     - ".review_rules"

# verify secrets:
#   extends:
#     - ".verify_secrets"
#     - ".review_rules"

# apply :
#   extends:
#     - ".apply_configmap"
#     - ".review_rules"


# ## Build image and configs. Push both to project registry
# build image:
#   extends:
#     - ".build_image"
#     - ".build_image_rules"

# build review configmap:
#   extends:
#     - ".build_review_config"
#     - ".review_rules"


# ## Deploy project for review. Gracefully remove after 1 week.
# review:
#   extends:
#     - ".review"
#     - ".review_rules"

# stop review:
#   extends:
#     - ".stop_review"
#     - ".stop_review_rules"


#
## ---------- Pipeline configuration ----------
#
variables:
  #
  # other global variables are set in GitLab Admin
  #
  # GENERIC_DEPLOYMENT: "true"
  #
  #   - if GENERIC_DEPLOYMENT is set to anything but "true", the pipeline expects this
  #     project to have a `deploy/` folder. See https://infrastructure-documentation.ltc.bcit.ca/.
  #
  # Set COMMON_NAMESPACE to combine apps into one namespace.
  # COMMON_NAMESPACE: ""
  #
  # Set SKIP_BUILD to skip the build stage and deploy the latest image
  # SKIP_BUILD: "true"
  #
  PIPELINE_DEBUG: "true"
#
#
#
## ---------- It's generally bad to change anything below here ----------
#
#
#
## Include common scripts
include:
  - project: deployments/ci-config
    file:
      # - project-init.yml
      - get-info.yaml
      - build.yaml
      - common.yaml
      - verify.yaml
      - rules.yaml
      - review.yaml
  # - template: Jobs/Secret-Detection.gitlab-ci.yml
  # - template: Jobs/SAST.gitlab-ci.yml


## Specify which runner should pick up pipeline jobs
default:
  tags:
    - review


## Cache jobs based on branch
cache:
  key: $CI_COMMIT_REF_SLUG


## Configure security scanning
# sast:
#   stage: test
#   extends:
#     - ".deploy_stable_rules"


## Configure merge request pipelines
workflow:
  rules:
    # - if: $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS && $CI_PIPELINE_SOURCE == "push"
    #   when: never
    - if: "$CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS"
      when: never
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" || $CI_COMMIT_BRANCH || $CI_COMMIT_TAG

