# LTC GitLab CI/CD Pipeline

# General Steps
# 1. Gather info




include:
  - project: 'deployments/build-scripts'
    file: '.gitlab-ci-template.yml'

stages:
  - gather_info
  - build
  - hydrate
  - deploy
  # - test
  # - cleanup

# get environment:
#   stage: gather_info
#   extends: .get_version

# build image:                     # Build image with Kaniko
#   stage: build
#   extends:
#     - .build_image
#     - .feature_branch_rules

prepare hydration:
  stage: hydrate
  extends:
    - .configure_docker_connection
    - .feature_branch_rules


hydrate deployment:
  stage: hydrate
  extends:
    - .render_manifests
    - .feature_branch_rules


.use_context: &use_context
  - kubectl config get-contexts 
  - kubectl config use-context ${CI_PROJECT_ROOT_NAMESPACE}/gitlab-kubernetes-agent:gitlab-kubernetes-agent


deploy for review:
  stage: deploy
  image: registry.dev.ltc.bcit.ca/ltc-infrastructure/images/kpt-git-kubectl-docker
  variables:
    BUILD_ENV: dev
  extends:
    - .feature_branch_rules
  needs:
  - job: hydrate deployment
    artifacts: true
  script:
    - cat dev/Kptfile
    - *use_context
    - "kubectl get resourcegroup -o json -n $CI_COMMIT_REF_SLUG | jq '{inventory: {namespace: .items[].metadata.name,name: .items[].metadata.name, inventoryID: .items[].metadata.labels.\"cli-utils.sigs.k8s.io/inventory-id\"} }' | yq e -P - >> Kptfile"
    - cat dev/Kptfile
    # - kpt live init $BUILD_ENV
    # - kpt live apply --inventory-policy=adopt $BUILD_ENV
    # - kpt live destroy $BUILD_ENV
    - ls -lah dev
  cache:
    key: $CI_COMMIT_REF_SLUG
    paths:
      - $BUILD_ENV/Kptfile
  artifacts:
    paths:
      - $BUILD_ENV/Kptfile
  # environment:
  #   name: $DEV_CLUSTER_NAME/review/$CI_COMMIT_REF_SLUG
  #   url: http://$CI_PROJECT_NAME.$DEV_CLUSTER_NAME.$DEV_HOST/$CI_COMMIT_REF_SLUG
    # on_stop: stop_review
    # auto_stop_in: 1 week


# build_latest:                         # Build image with Kaniko
#   stage: build
#   variables:
#     BUILD_ENV: staging
#   extends:
#     - .build_image
#     - .main_branch_rules


# deploy_latest:                        # Deploy `latest` image to staging cluster
#   stage: deploy
#   extends: 
#     - .main_branch_rules
#   variables:
#     BUILD_ENV: staging
#   secrets:
#     TLS_CRT:
#       vault: ssl-certificates/star-dev-ltc-bcit-ca-bundle.crt.base64@ltc-infrastructure
#       file: false
#     TLS_KEY:
#       vault: ssl-certificates/star-dev-ltc-bcit-ca.key.base64@ltc-infrastructure
#       file: false
#   script:
#     - !reference [.set_deploy_envs, script]                   # set cluster env
#     - !reference [.replace_namespace, script]         # add namespace annotations to ensure it's in the default Rancher project
#     - !reference [.patch_deployment, script]        # add annotations about build to deployment
#     - !reference [.kustomize_image, script]           # patch deployment to pull latest commit image
#     - !reference [.add_common_annotations, script]    # link deployment to GitLab Environment/Operations dashboards
#     - !reference [.create_tls_secret, script]         # create TLS secret
#     - !reference [.patch_ingress, script]             # replace ingress with rewrite-targets, sub-paths
#     - !reference [.verify_kustomization, script]      # validate kustomization
#     - "kubectl kustomize deploy/overlays/$BUILD_ENV \
#         | kubectl apply -f -"                         # apply kustomized deployment
#   environment:
#     name: staging
#     url: https://$STAGING_HOST/$CI_PROJECT_NAME
#     kubernetes:
#       namespace: $PROD_NAMESPACE      # update to '$CI_PROJECT_NAME' if projects are independent


# semver_tag:                           # Creates a semantic-version tag that is applied to the release branch
#   stage: analyze_for_tagging
#   extends: 
#     - .semver_tag_rules
#     - .semantic_release
#   secrets:
#     GITLAB_TOKEN:
#       vault: dependabot-$CI_PROJECT_NAME/token@tokens
#       file: false
#   script:
#     - "semantic-release \
#         --branches release \
#         --repository-url $CI_PROJECT_URL \
#         --plugins '@semantic-release/commit-analyzer, \
#           @semantic-release/release-notes-generator, \
#           @semantic-release/gitlab'"


# build_stable:                         # Build image with Kaniko
#   stage: build
#   variables:
#     BUILD_ENV: prod
#   extends:
#     - .build_image
#     - .release_branch_rules


# deploy_production:                    # Deploy `stable` image to production cluster
#   stage: deploy
#   extends: 
#     - .release_branch_rules
#   variables:
#     BUILD_ENV: prod
#   secrets:
#     TLS_CRT:
#       vault: ssl-certificates/star-dev-ltc-bcit-ca-bundle.crt.base64@ltc-infrastructure
#       file: false
#     TLS_KEY:
#       vault: ssl-certificates/star-dev-ltc-bcit-ca.key.base64@ltc-infrastructure
#       file: false
#   script:
#     - !reference [.set_deploy_envs, script]                   # set cluster env
#     - !reference [.replace_namespace, script]         # add namespace annotations to ensure it's in the default Rancher project
#     - !reference [.patch_deployment, script]        # add annotations about build to deployment
#     - !reference [.kustomize_image, script]           # patch deployment to pull latest commit image
#     - !reference [.add_common_annotations, script]    # link deployment to GitLab Environment/Operations dashboards
#     - !reference [.create_tls_secret, script]         # create TLS secret
#     - !reference [.patch_ingress, script]             # replace ingress with rewrite-targets, sub-paths
#     - !reference [.verify_kustomization, script]      # validate kustomization
#     - "kubectl kustomize deploy/overlays/$BUILD_ENV \
#         | kubectl apply -f -"                         # apply kustomized deployment
#   environment:
#     name: production
#     url: https://$PROD_HOST/$CI_PROJECT_NAME
#     kubernetes:
#       namespace: $PROD_NAMESPACE      # update to '$CI_PROJECT_NAME' if projects are independent


# stop_review:                          # Stop review environment
#   stage: cleanup
#   extends: .feature_branch_rules
#   script:
#     - |
#       kpt live destroy $BUILD_ENV
#   environment:
#     name: $DEV_CLUSTER_NAME/review/$CI_COMMIT_REF_SLUG
#     kubernetes:
#       namespace: $CI_COMMIT_REF_SLUG
#     action: stop
#   rules:
#     - if: '$CI_PIPELINE_SOURCE == "push" && $CI_OPEN_MERGE_REQUESTS'
#       when: manual
#   tags:
#     - $DEV_CLUSTER_NAME



# build:review:
#   stage: build
#   image: registry.dev.ltc.bcit.ca/ltc-infrastructure/images/kpt-git
#   variables:
#     BUILD_ENV: dev
#   # before_script:
#   #   - mkdir -p ./deploy
#   #   - kpt pkg get git@issues.ltc.bcit.ca:ltc-infrastructure/documentation.git/build-scripts@v0.1 ./deploy/build-scripts
#   #   - ls -lah
#   extends:
#     - .get_version
#     - .build_image
#     # - .feature_branch_rules
#   tags:
#     - production

# docker-test:
#   stage: build
#   variables:
#     FF_NETWORK_PER_BUILD: "true"     # activate container-to-container networking
#     DOCKER_HOST: tcp://dev-gate3.ltc.bcit.ca:2376
#   script:
#     - export VAULT_TOKEN="$(vault write -field=token auth/gitlab-jwt/login role=$VAULT_AUTH_ROLE jwt=$CI_JOB_JWT)"
#     - docker --version
#     - kpt fn eval wordpress -i set-labels:v0.1 -- env=dev
#   tags:
#     - dev-cp


# Pipeline variables
variables:                  # other global variables are set in GitLab Admin: https://issues.ltc.bcit.ca/admin/application_settings/ci_cd
  CLUSTER_NAME: "dev-cp"    # options: dev-cp, dev-vsm
  # PROD_NAMESPACE: "qcon"    # combine apps into one namespace if following microservice pattern; otherwise, set to ""
  DEPLOYMENT_PACKAGE_URL: https://gitlab-ci-token:$CI_JOB_TOKEN@$CI_SERVER_HOST/deployments/$CI_PROJECT_NAME.git/$BUILD_ENV
  VAULT_AUTH_ROLE: "dependabot-$CI_PROJECT_NAME"    # Standard policies: [default, jwt, read-tokens, read-apps, read-ssl-certificates]
  GIT_FETCH_EXTRA_FLAGS: "--tags"
  PIPELINE_DEBUG: "true"
  CI_DEBUG_TRACE: "false"
  KUBE_CONTEXT: "ltc-infrastructure/gitlab-kubernetes-agent:gitlab-kubernetes-agent"
