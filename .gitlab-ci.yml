# Default LTC GitLab CI/CD Pipeline

## General Steps
# 1. Gather info
# 2. Build Image
# 3. Generate deployment package
# 4. Deploy


stages:
  - analyze for new tag
  - gather existing tag info
  - build
  - deploy
  - cleanup


# Run Semantic Release
semver tag:
  image: registry.dev.ltc.bcit.ca/ltc-infrastructure/images/semantic-release
  stage: analyze for new tag
  variables:
    GIT_AUTHOR_NAME: $GITLAB_USER_LOGIN
    GIT_AUTHOR_EMAIL: $GITLAB_USER_EMAIL
    GIT_COMMITTER_NAME: $GITLAB_USER_LOGIN
    GIT_COMMITTER_EMAIL: $GITLAB_USER_EMAIL
  extends: 
    - .semantic_release
  secrets:
    GITLAB_TOKEN:
      vault: dependabot-$CI_PROJECT_NAME/token@tokens
      file: false
  script:
    - "semantic-release \
        --branches main \
        --debug \
        --repository-url $CI_PROJECT_URL \
        --plugins '@semantic-release/commit-analyzer, \
          @semantic-release/release-notes-generator, \
          @semantic-release/gitlab'"
  tags:
    - $CLUSTER_NAME
  rules:
    - if: '$CI_MERGE_REQUEST_EVENT_TYPE == "detached"'
      when: never
    - if: '$CI_COMMIT_REF_SLUG == "main" && $CI_PIPELINE_SOURCE == "push"'


## Determine existing git tags
get tags:
  stage: gather existing tag info
  extends: .get_tags
  tags:
    - $CLUSTER_NAME


## Build feat/fix branch image and push to project registry
build image:
  stage: build
  extends:
    - .build_image
  tags:
    - $CLUSTER_NAME


## Deploy feat/fix branch package
deploy review package:
  stage: deploy
  variables:
    BUILD_ENV: dev
    DEPLOY_NAMESPACE: $CI_COMMIT_REF_SLUG
    DEPLOY_HOST: $CI_PROJECT_NAME.$CLUSTER_NAME.reviews.dev.ltc.bcit.ca
    DEPLOYMENT_PACKAGE_URL: https://gitlab-ci-token:$CI_JOB_TOKEN@$CI_SERVER_HOST/deployments/$CI_PROJECT_NAME.git/packages/$BUILD_ENV
    DEPLOYMENT_PACKAGE_VERSION: "@v0.3"
  extends:
    - .deploy_review_package
    - .set_review_environment
  needs:
  - job: get tags
    artifacts: true
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "release"'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" || $CI_MERGE_REQUEST_EVENT_TYPE == "detached"'
  tags:
    - ${CLUSTER_NAME}


## Build main branch image and push to project registry
# build latest image:
#   stage: build
#   extends:
#     - .build_image
#   tags:
#     - $CLUSTER_NAME
#   rules:
#     - if: '$CI_PIPELINE_SOURCE == "merge_request_event" || $CI_MERGE_REQUEST_EVENT_TYPE == "detached"'
#       when: never
#     - if: $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS
#       when: never
#     - if: '$CI_COMMIT_REF_SLUG == "main" && $CI_PIPELINE_SOURCE == "push"'


## Deploy latest image (staging)
# - trigger staging pipeline in deployments/{projectName}/staging
  # tags:
  #   - staging
# deploy staging:
#   image: curlimages/curl:latest
#   stage: deploy
#   needs:
#     - job: build latest image
#       artifacts: true
#   variables:
#     MANIFEST_PROJECT_ID: 30770380
#     TARGET_ENVIRONMENT: staging
#   script:
#   - printenv
#   - 'curl --fail --request POST --form token=${CI_JOB_TOKEN} --form ref=main --form "variables[IMAGE_REF]=${IMAGE_REF}" --form "variables[TARGET_ENVIRONMENT]=${TARGET_ENVIRONMENT}" "${CI_API_V4_URL}/projects/${MANIFEST_PROJECT_ID}/trigger/pipeline"'
#   environment:
#     name: staging


## Deploy stable image (production)
# - trigger production pipeline that:
#   - unpacks trigger variables (CI_JOB_TOKEN, branch ref, image ref, target environment)
#     eg. --form token=${CI_JOB_TOKEN} --form ref=main --form "variables[IMAGE_REF]=${IMAGE_REF}" --form "variables[TARGET_ENVIRONMENT]=${TARGET_ENVIRONMENT}" "${CI_API_V4_URL}/projects/${MANIFEST_PROJECT_ID}/trigger/pipeline"'
#   - hydrates manifests
#   - commits to registry (at `/releases` path)
  # rules:
  #   - if: $CI_COMMIT_TAG
  # tags:
  #   - production
  
deploy:production:
  image: curlimages/curl:latest
  stage: deploy
  needs:
    - job: get tags
      artifacts: true
  variables:
    MANIFEST_PROJECT_ID: 30770380
    TARGET_ENVIRONMENT: production
  script:
  - echo "production deploy"
  # - 'curl --fail --request POST --form token=${CI_JOB_TOKEN} --form ref=main --form "variables[IMAGE_REF]=${IMAGE_REF}" --form "variables[TARGET_ENVIRONMENT]=${TARGET_ENVIRONMENT}" "${CI_API_V4_URL}/projects/${MANIFEST_PROJECT_ID}/trigger/pipeline"'
  environment:
    name: production
  rules:
    - if: '$CI_COMMIT_TAG'
  tags:
    - production


## Removes deployment (and all assets in the namespace)
stop_review:                          # Stop review environment
  stage: cleanup
  variables:
    BUILD_ENV: dev
    DEPLOY_NAMESPACE: $CI_COMMIT_REF_SLUG
  extends:
    - .undeploy_review_package
  tags:
    - ${CLUSTER_NAME}


## Include common scripts
include:
  - project: 'deployments/ci-config'
    file: 
      - '.semver-tag.yml'
      - '.get-tags.yml'
      - '.build.yml'
      - '.deploy.yml'
      - '.rules.yml'


workflow:
  rules:
    - if: $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS && $CI_PIPELINE_SOURCE == "push"
      when: never
    - if: '$CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" || $CI_COMMIT_BRANCH || $CI_COMMIT_TAG'


## Pipeline variables
variables:                  # other global variables are set in GitLab Admin: https://issues.ltc.bcit.ca/admin/application_settings/ci_cd
  CLUSTER_NAME: "dev-cp"    # options: dev-cp, dev-vsm
  # PROD_NAMESPACE: "qcon"    # combine apps into one namespace if following microservice pattern; otherwise, set to ""
  VAULT_AUTH_ROLE: "dependabot-$CI_PROJECT_NAME"    # Standard policies: [default, jwt, read-tokens, read-apps, read-ssl-certificates]
  GIT_FETCH_EXTRA_FLAGS: "--tags"
  PIPELINE_DEBUG: "true"
  KUBE_CONTEXT: "ltc-infrastructure/gitlab-kubernetes-agent:gitlab-kubernetes-agent"
